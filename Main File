--[[

Originally made by Purble_Dev
Discord: @purbledev
Date: 04.05.2025

Enjoy!


QUICK HEADS UP:
This script is for taking care of enemies with your bow, you can see how the script works in this game: https://www.roblox.com/games/72409643525900/Idle-gamer

]]--

local handler = require(game.ServerScriptService.Handler)

local upgrades = handler.upgradesList
-- Function to handle tool activation (shooting)
local tool = script.Parent
local fireRate = tool:WaitForChild("FireRate")
local range = tool:WaitForChild("Range")
local damage = tool:WaitForChild("Damage")
local projectileSpeed = tool:WaitForChild("ProjectileSpeed")
local projectiles = tool:WaitForChild("Projectiles")
local critChance = tool:WaitForChild("CriticalChance")
local critDmg = tool:WaitForChild("CriticalDamage")

local handle = tool:WaitForChild("Handle")
local fire = tool:WaitForChild("Fire")

local enemiesFolder = workspace:WaitForChild("Enemies")
local serverStorage = game:GetService("ServerStorage")
local TweenService = game:GetService("TweenService")
local arrowTemplate = serverStorage.Projectiles:WaitForChild("Arrow")

local lastShotTime = 0
local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)

-- Funkcja do znajdowania najbliższego wroga w zasięgu
local function findClosestEnemy(player)
	local closestEnemy = nil
	local shortestDistance = range.Value + 1 + range.Value * (upgrades[6].Increase * upgrades[6].PlayerHas)/100

	for _, enemy in pairs(enemiesFolder:GetChildren()) do
		if enemy:FindFirstChild("HumanoidRootPart") then
			local humanoid = enemy:FindFirstChild("Humanoid")

			-- Sprawdzenie, czy wróg żyje
			if humanoid and humanoid.Health > 0 then
				local enemyPosition = enemy.HumanoidRootPart.Position
				local distance = (enemyPosition - handle.Position).Magnitude

				if distance < shortestDistance then
					closestEnemy = enemy
					shortestDistance = distance
				end
			end
		end
	end

	return closestEnemy
end

-- Funkcja na strzałę pojedynczą
local function fireArrow1(targetEnemy, player, doNoclip)
	if targetEnemy and targetEnemy:FindFirstChild("HumanoidRootPart") then
		-- Clone the arrow and position it at the bow's handle
		local hittedHumans = {}
		
		fire.PlaybackSpeed = math.random(80, 110) /100
		fire:Play()
		local arrow = arrowTemplate:Clone()
		arrow.CFrame = handle.CFrame
		arrow.Parent = workspace
		
		if doNoclip == true then
			arrow.Highlight.OutlineColor = Color3.new(0.466667, 0.854902, 0.054902)
		end

		-- Calculate the direction and distance to the enemy
		local targetPosition = targetEnemy.HumanoidRootPart.Position
		local distanceToTarget = (targetPosition - arrow.Position).Magnitude

		-- Calculate the time required for the arrow to reach the target based on projectile speed
		local travelTime = distanceToTarget / projectileSpeed.Value / 5

		local trueDistance = distanceToTarget/travelTime*5

		local direction = (targetPosition - arrow.Position).Unit

		local newTargetPosition = arrow.Position + (direction * trueDistance)

		arrow.CFrame = CFrame.new(arrow.Position, newTargetPosition)

		local tweenInfo = TweenInfo.new(5, Enum.EasingStyle.Linear)
		local tweenGoal = {Position = newTargetPosition}

		local arrowTween = TweenService:Create(arrow, tweenInfo, tweenGoal)

		arrowTween:Play()

		-- Collision detection logic
		local traveledDistance = 0
		local connection
		connection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
			-- Update traveled distance
			traveledDistance = traveledDistance + (projectileSpeed.Value * deltaTime)

			-- Check for collisions
			local raycastResult = workspace:Raycast(arrow.Position, (targetPosition - arrow.Position).Unit * 2) -- Short ray for impact detection
			

			
			if raycastResult then
				local hitPart = raycastResult.Instance

				-- Check if the hit part is the target enemy or another enemy
				local hitParent = hitPart.Parent
				local humanoid = hitParent:FindFirstChild("Humanoid")

				if humanoid and humanoid.Health > 0 and hitParent ~= player.Character and not table.find(hittedHumans, humanoid) then
					-- Zadaj obrażenia wrogowi
					table.insert(hittedHumans, humanoid)
					local rageBonus = 1
					
					if player.Character.Humanoid.Health / player.Character.Humanoid.MaxHealth <= 0.30 then
						
						rageBonus = 1 + (upgrades[17].Increase * upgrades[17].PlayerHas) / 100
						
					end
					
					
					local dmg = damage.Value * (1 + (upgrades[1].Increase * upgrades[1].PlayerHas) / 100) * rageBonus
					local critVal = critChance.Value + (upgrades[4].Increase * upgrades[4].PlayerHas)

					local letsSee = math.random(1, 100)

					if doNoclip == false then
						arrow:Destroy()
						connection:Disconnect()
						table.clear(hittedHumans)
					end

					if letsSee <= critVal then

						local clone = hitParent.Head.BillboardGui2.ImageLabel:Clone()
						clone.Name = "Clone"
						clone.Parent = hitParent.Head.BillboardGui2
						clone.Position = UDim2.new(0,0,0.5,0)
						clone.Visible = true
						dmg *= (1 + (critDmg.Value + upgrades[5].Increase * upgrades[5].PlayerHas) / 100)
						humanoid:TakeDamage(dmg)
						hitParent.crit_received:Play()
						TweenService:Create(clone, tweenInfo, {Position = UDim2.new(0,0,0.1,0)}):Play()
						wait(0.9)
						clone:Destroy()
					else
						
						humanoid:TakeDamage(dmg)
						
					end
				elseif hitParent == workspace.Map.Walls then
					-- Zniszczenie strzały, jeśli trafi w ścianę
					if doNoclip == false then
						arrow:Destroy()
						connection:Disconnect()
						table.clear(hittedHumans)
					end
					
				end
			elseif traveledDistance >= range.Value then
				-- Destroy the arrow if it exceeds the max range
				arrow:Destroy()
				connection:Disconnect()
				table.clear(hittedHumans)
			end
		end)

		-- Automatically destroy the arrow after 5 seconds as a failsafe
		game:GetService("Debris"):AddItem(arrow, 5)
	end
end

local function fireArrow2(targetEnemy, player, doNoclip)
	if targetEnemy and targetEnemy:FindFirstChild("HumanoidRootPart") then
		fire.PlaybackSpeed = math.random(80, 110) / 100
		fire:Play()
		local hittedHumans = {}
		-- Oblicz kierunek do celu
		local targetPosition = targetEnemy.HumanoidRootPart.Position
		local direction = (targetPosition - handle.Position).Unit

		-- Ustawienie rozdzielenia strzałek na lewo i prawo (rozsunięcie poziome)
		local horizontalSpread = 0.03 -- Rozsunięcie strzałek w lewo i prawo o 5 jednostek

		-- Definiujemy dwa strzały dla formy | |
		for i = -1, 1, 2 do
			-- Klonowanie strzały i ustawienie jej przy uchwycie
			
			local arrow = arrowTemplate:Clone()
			arrow.CFrame = handle.CFrame
			arrow.Parent = workspace
			
			if doNoclip == true then
				arrow.Highlight.OutlineColor = Color3.new(0.466667, 0.854902, 0.054902)
			end

			-- Skorygowanie kierunku dla rozdzielenia na boki (horyzontalnie)
			local spreadDirection = (direction + Vector3.new(i * horizontalSpread, 0, 0)).Unit

			local distanceToTarget = (targetPosition - arrow.Position).Magnitude

			-- Calculate the time required for the arrow to reach the target based on projectile speed
			local travelTime = distanceToTarget / projectileSpeed.Value / 5

			local trueDistance = distanceToTarget/travelTime*5

			local newTargetPosition = arrow.Position + (spreadDirection * trueDistance)

			arrow.CFrame = CFrame.new(arrow.Position, newTargetPosition)

			local tweenInfo = TweenInfo.new(5, Enum.EasingStyle.Linear)
			local tweenGoal = {Position = newTargetPosition}

			local arrowTween = TweenService:Create(arrow, tweenInfo, tweenGoal)

			arrowTween:Play()

			-- Logika wykrywania kolizji
			local traveledDistance = 0
			local connection
			connection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
				traveledDistance = traveledDistance + (projectileSpeed.Value * deltaTime)

				-- Sprawdzanie kolizji
				local raycastResult = workspace:Raycast(arrow.Position, spreadDirection * 2) -- Krótki promień do wykrywania kolizji

				if raycastResult then
					local hitPart = raycastResult.Instance

					-- Check if the hit part is the target enemy or another enemy
					local hitParent = hitPart.Parent
					local humanoid = hitParent:FindFirstChild("Humanoid")

					if humanoid and humanoid.Health > 0 and hitParent ~= player.Character and not table.find(hittedHumans, humanoid) then
						-- Zadaj obrażenia wrogowi
						table.insert(hittedHumans, humanoid)
						local rageBonus = 1

						if player.Character.Humanoid.Health / player.Character.Humanoid.MaxHealth <= 0.30 then

							rageBonus = 1 + (upgrades[17].Increase * upgrades[17].PlayerHas) / 100

						end

						local dmg = damage.Value * (1 + (upgrades[1].Increase * upgrades[1].PlayerHas) / 100) * rageBonus

						local critVal = critChance.Value + (upgrades[4].Increase * upgrades[4].PlayerHas)

						local letsSee = math.random(1, 100)

						if doNoclip == false then
							arrow:Destroy()
							connection:Disconnect()
							table.clear(hittedHumans)
						end

						if letsSee <= critVal then

							local clone = hitParent.Head.BillboardGui2.ImageLabel:Clone()
							clone.Name = "Clone"
							clone.Parent = hitParent.Head.BillboardGui2
							clone.Position = UDim2.new(0,0,0.5,0)
							clone.Visible = true
							dmg *= (1 + (critDmg.Value + upgrades[5].Increase * upgrades[5].PlayerHas) / 100)
							humanoid:TakeDamage(dmg)
							hitParent.crit_received:Play()
							TweenService:Create(clone, tweenInfo, {Position = UDim2.new(0,0,0.1,0)}):Play()
							wait(0.9)
							clone:Destroy()
						else

							humanoid:TakeDamage(dmg)

						end
					elseif hitParent == workspace.Map.Walls then
						-- Zniszczenie strzały, jeśli trafi w ścianę
						if doNoclip == false then
							arrow:Destroy()
							connection:Disconnect()
							table.clear(hittedHumans)
						end

					end
				elseif traveledDistance >= range.Value then
					-- Destroy the arrow if it exceeds the max range
					arrow:Destroy()
					connection:Disconnect()
					table.clear(hittedHumans)
				end
			end)

			-- Automatyczne zniszczenie strzały po 5 sekundach jako zabezpieczenie
			game:GetService("Debris"):AddItem(arrow, 5)
		end
	end
end

local function fireArrow3(targetEnemy, player, doNoclip)
	if targetEnemy and targetEnemy:FindFirstChild("HumanoidRootPart") then
		fire.PlaybackSpeed = math.random(80, 110) / 100
		fire:Play()
		local hittedHumans = {}
		-- Oblicz kierunek do celu
		local targetPosition = targetEnemy.HumanoidRootPart.Position
		local direction = (targetPosition - handle.Position).Unit

		-- Ustawienie rozdzielenia strzałek na lewo i prawo (rozsunięcie poziome)
		local horizontalSpread = 0.1 -- Rozsunięcie strzałek w lewo i prawo o 0.03 jednostki

		-- Definiujemy trzy strzały: lewą, prawą i środkową
		for i = -1, 1 do
			-- Klonowanie strzały i ustawienie jej przy uchwycie
			local arrow = arrowTemplate:Clone()
			arrow.CFrame = handle.CFrame
			arrow.Parent = workspace
			
			if doNoclip == true then
				arrow.Highlight.OutlineColor = Color3.new(0.466667, 0.854902, 0.054902)
			end
			-- Skorygowanie kierunku dla rozdzielenia na boki (horyzontalnie), strzała środkowa leci prosto
			local spreadDirection
			if i == 0 then
				spreadDirection = direction -- Strzała środkowa leci prosto
			else
				spreadDirection = (direction + Vector3.new(i * horizontalSpread, 0, 0)).Unit -- Strzały boczne
			end

			local distanceToTarget = (targetPosition - arrow.Position).Magnitude

			-- Calculate the time required for the arrow to reach the target based on projectile speed
			local travelTime = distanceToTarget / projectileSpeed.Value / 5

			local trueDistance = distanceToTarget/travelTime*5

			local newTargetPosition = arrow.Position + (spreadDirection * trueDistance)

			arrow.CFrame = CFrame.new(arrow.Position, newTargetPosition)

			local tweenInfo = TweenInfo.new(5, Enum.EasingStyle.Linear)
			local tweenGoal = {Position = newTargetPosition}

			local arrowTween = TweenService:Create(arrow, tweenInfo, tweenGoal)

			arrowTween:Play()

			-- Logika wykrywania kolizji
			local traveledDistance = 0
			local connection
			connection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
				traveledDistance = traveledDistance + (projectileSpeed.Value * deltaTime)

				-- Sprawdzanie kolizji
				local raycastResult = workspace:Raycast(arrow.Position, spreadDirection * 2) -- Krótki promień do wykrywania kolizji

				if raycastResult then
					local hitPart = raycastResult.Instance

					-- Check if the hit part is the target enemy or another enemy
					local hitParent = hitPart.Parent
					local humanoid = hitParent:FindFirstChild("Humanoid")

					if humanoid and humanoid.Health > 0 and hitParent ~= player.Character and not table.find(hittedHumans, humanoid) then
						-- Zadaj obrażenia wrogowi
						table.insert(hittedHumans, humanoid)
						local rageBonus = 1

						if player.Character.Humanoid.Health / player.Character.Humanoid.MaxHealth <= 0.30 then

							rageBonus = 1 + (upgrades[17].Increase * upgrades[17].PlayerHas) / 100

						end

						local dmg = damage.Value * (1 + (upgrades[1].Increase * upgrades[1].PlayerHas) / 100) * rageBonus

						local critVal = critChance.Value + (upgrades[4].Increase * upgrades[4].PlayerHas)

						local letsSee = math.random(1, 100)

						if doNoclip == false then
							arrow:Destroy()
							connection:Disconnect()
							table.clear(hittedHumans)
						end

						if letsSee <= critVal then

							local clone = hitParent.Head.BillboardGui2.ImageLabel:Clone()
							clone.Name = "Clone"
							clone.Parent = hitParent.Head.BillboardGui2
							clone.Position = UDim2.new(0,0,0.5,0)
							clone.Visible = true
							dmg *= (1 + (critDmg.Value + upgrades[5].Increase * upgrades[5].PlayerHas) / 100)
							humanoid:TakeDamage(dmg)
							hitParent.crit_received:Play()
							TweenService:Create(clone, tweenInfo, {Position = UDim2.new(0,0,0.1,0)}):Play()
							wait(0.9)
							clone:Destroy()
						else

							humanoid:TakeDamage(dmg)

						end
					elseif hitParent == workspace.Map.Walls then
						-- Zniszczenie strzały, jeśli trafi w ścianę
						if doNoclip == false then
							arrow:Destroy()
							connection:Disconnect()
							table.clear(hittedHumans)
						end

					end
				elseif traveledDistance >= range.Value then
					-- Destroy the arrow if it exceeds the max range
					arrow:Destroy()
					connection:Disconnect()
					table.clear(hittedHumans)
				end
			end)

			-- Automatyczne zniszczenie strzały po 5 sekundach jako zabezpieczenie
			game:GetService("Debris"):AddItem(arrow, 5)
		end
	end
end

local function fireArrow4(targetEnemy, player, doNoclip)
	if targetEnemy and targetEnemy:FindFirstChild("HumanoidRootPart") then
		fire.PlaybackSpeed = math.random(80, 110) / 100
		fire:Play()
		local hittedHumans = {}
		-- Oblicz kierunek do celu
		local targetPosition = targetEnemy.HumanoidRootPart.Position
		local direction = (targetPosition - handle.Position).Unit

		-- Ustawienie rozdzielenia strzałek na lewo i prawo (rozsunięcie poziome)
		local horizontalSpread = 0.15 -- Rozsunięcie strzałek w lewo i prawo o jednostki

		-- Definiujemy wartości dla trzech strzał: lewa, prawa (bez środkowej)
		local spreadOffsets = {-1.5, -0.5, 0.5, 1.5} -- Równe rozmieszczenie bez i = 0

		for _, offset in ipairs(spreadOffsets) do
			-- Klonowanie strzały i ustawienie jej przy uchwycie
			local arrow = arrowTemplate:Clone()
			arrow.CFrame = handle.CFrame
			arrow.Parent = workspace
			
			if doNoclip == true then
				arrow.Highlight.OutlineColor = Color3.new(0.466667, 0.854902, 0.054902)
			end

			-- Skorygowanie kierunku dla rozdzielenia na boki (horyzontalnie)
			local spreadDirection = (direction + Vector3.new(offset * horizontalSpread, 0, 0)).Unit

			local distanceToTarget = (targetPosition - arrow.Position).Magnitude

			-- Calculate the time required for the arrow to reach the target based on projectile speed
			local travelTime = distanceToTarget / projectileSpeed.Value / 5

			local trueDistance = distanceToTarget/travelTime*5

			local newTargetPosition = arrow.Position + (spreadDirection * trueDistance)

			arrow.CFrame = CFrame.new(arrow.Position, newTargetPosition)

			local tweenInfo = TweenInfo.new(5, Enum.EasingStyle.Linear)
			local tweenGoal = {Position = newTargetPosition}

			local arrowTween = TweenService:Create(arrow, tweenInfo, tweenGoal)

			arrowTween:Play()

			-- Logika wykrywania kolizji
			local traveledDistance = 0
			local connection
			connection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
				traveledDistance = traveledDistance + (projectileSpeed.Value * deltaTime)

				-- Sprawdzanie kolizji
				local raycastResult = workspace:Raycast(arrow.Position, spreadDirection * 2) -- Krótki promień do wykrywania kolizji

				if raycastResult then
					local hitPart = raycastResult.Instance

					-- Check if the hit part is the target enemy or another enemy
					local hitParent = hitPart.Parent
					local humanoid = hitParent:FindFirstChild("Humanoid")

					if humanoid and humanoid.Health > 0 and hitParent ~= player.Character and not table.find(hittedHumans, humanoid) then
						-- Zadaj obrażenia wrogowi
						table.insert(hittedHumans, humanoid)
						local rageBonus = 1

						if player.Character.Humanoid.Health / player.Character.Humanoid.MaxHealth <= 0.30 then

							rageBonus = 1 + (upgrades[17].Increase * upgrades[17].PlayerHas) / 100

						end

						local dmg = damage.Value * (1 + (upgrades[1].Increase * upgrades[1].PlayerHas) / 100) * rageBonus

						local critVal = critChance.Value + (upgrades[4].Increase * upgrades[4].PlayerHas)

						local letsSee = math.random(1, 100)

						if doNoclip == false then
							arrow:Destroy()
							connection:Disconnect()
							table.clear(hittedHumans)
						end

						if letsSee <= critVal then

							local clone = hitParent.Head.BillboardGui2.ImageLabel:Clone()
							clone.Name = "Clone"
							clone.Parent = hitParent.Head.BillboardGui2
							clone.Position = UDim2.new(0,0,0.5,0)
							clone.Visible = true
							dmg *= (1 + (critDmg.Value + upgrades[5].Increase * upgrades[5].PlayerHas) / 100)
							humanoid:TakeDamage(dmg)
							hitParent.crit_received:Play()
							TweenService:Create(clone, tweenInfo, {Position = UDim2.new(0,0,0.1,0)}):Play()
							wait(0.9)
							clone:Destroy()
						else

							humanoid:TakeDamage(dmg)

						end
					elseif hitParent == workspace.Map.Walls then
						-- Zniszczenie strzały, jeśli trafi w ścianę
						if doNoclip == false then
							arrow:Destroy()
							connection:Disconnect()
							table.clear(hittedHumans)
						end

					end
				elseif traveledDistance >= range.Value then
					-- Destroy the arrow if it exceeds the max range
					arrow:Destroy()
					connection:Disconnect()
					table.clear(hittedHumans)
				end
			end)

			-- Automatyczne zniszczenie strzały po 5 sekundach jako zabezpieczenie
			game:GetService("Debris"):AddItem(arrow, 5)
		end
	end
end


local function fireArrow5(targetEnemy, player, doNoclip)
	if targetEnemy and targetEnemy:FindFirstChild("HumanoidRootPart") then
		fire.PlaybackSpeed = math.random(80, 110) / 100
		fire:Play()
		local hittedHumans = {}
		-- Oblicz kierunek do celu
		local targetPosition = targetEnemy.HumanoidRootPart.Position
		local direction = (targetPosition - handle.Position).Unit

		-- Ustawienie rozdzielenia strzałek na lewo i prawo (rozsunięcie poziome)
		local horizontalSpread = 0.15 -- Rozsunięcie strzałek w lewo i prawo o 0.03 jednostki

		-- Definiujemy trzy strzały: lewą, prawą i środkową
		for i = -2, 2 do
			-- Klonowanie strzały i ustawienie jej przy uchwycie
			local arrow = arrowTemplate:Clone()
			arrow.CFrame = handle.CFrame
			arrow.Parent = workspace
			
			if doNoclip == true then
				arrow.Highlight.OutlineColor = Color3.new(0.466667, 0.854902, 0.054902)
			end
			-- Skorygowanie kierunku dla rozdzielenia na boki (horyzontalnie), strzała środkowa leci prosto
			local spreadDirection
			if i == 0 then
				spreadDirection = direction -- Strzała środkowa leci prosto
			else
				spreadDirection = (direction + Vector3.new(i * horizontalSpread, 0, 0)).Unit -- Strzały boczne
			end

			local distanceToTarget = (targetPosition - arrow.Position).Magnitude

			-- Calculate the time required for the arrow to reach the target based on projectile speed
			local travelTime = distanceToTarget / projectileSpeed.Value / 5

			local trueDistance = distanceToTarget/travelTime*5

			local newTargetPosition = arrow.Position + (spreadDirection * trueDistance)

			arrow.CFrame = CFrame.new(arrow.Position, newTargetPosition)

			local tweenInfo = TweenInfo.new(5, Enum.EasingStyle.Linear)
			local tweenGoal = {Position = newTargetPosition}

			local arrowTween = TweenService:Create(arrow, tweenInfo, tweenGoal)

			arrowTween:Play()

			-- Logika wykrywania kolizji
			local traveledDistance = 0
			local connection
			connection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
				traveledDistance = traveledDistance + (projectileSpeed.Value * deltaTime)

				-- Sprawdzanie kolizji
				local raycastResult = workspace:Raycast(arrow.Position, spreadDirection * 2) -- Krótki promień do wykrywania kolizji

				if raycastResult then
					local hitPart = raycastResult.Instance

					-- Check if the hit part is the target enemy or another enemy
					local hitParent = hitPart.Parent
					local humanoid = hitParent:FindFirstChild("Humanoid")

					if humanoid and humanoid.Health > 0 and hitParent ~= player.Character and not table.find(hittedHumans, humanoid) then
						-- Zadaj obrażenia wrogowi
						table.insert(hittedHumans, humanoid)
						local rageBonus = 1

						if player.Character.Humanoid.Health / player.Character.Humanoid.MaxHealth <= 0.30 then

							rageBonus = 1 + (upgrades[17].Increase * upgrades[17].PlayerHas) / 100

						end

						local dmg = damage.Value * (1 + (upgrades[1].Increase * upgrades[1].PlayerHas) / 100) * rageBonus

						local critVal = critChance.Value + (upgrades[4].Increase * upgrades[4].PlayerHas)

						local letsSee = math.random(1, 100)

						if doNoclip == false then
							arrow:Destroy()
							connection:Disconnect()
							table.clear(hittedHumans)
						end

						if letsSee <= critVal then

							local clone = hitParent.Head.BillboardGui2.ImageLabel:Clone()
							clone.Name = "Clone"
							clone.Parent = hitParent.Head.BillboardGui2
							clone.Position = UDim2.new(0,0,0.5,0)
							clone.Visible = true
							
							dmg *= (1 + (critDmg.Value + upgrades[5].Increase * upgrades[5].PlayerHas) / 100)
							humanoid:TakeDamage(dmg)
							hitParent.crit_received:Play()
							TweenService:Create(clone, tweenInfo, {Position = UDim2.new(0,0,0.1,0)}):Play()
							wait(0.9)
							clone:Destroy()
						else

							humanoid:TakeDamage(dmg)

						end
					elseif hitParent == workspace.Map.Walls then
						-- Zniszczenie strzały, jeśli trafi w ścianę
						if doNoclip == false then
							arrow:Destroy()
							connection:Disconnect()
							table.clear(hittedHumans)
						end

					end
				elseif traveledDistance >= range.Value then
					-- Destroy the arrow if it exceeds the max range
					arrow:Destroy()
					connection:Disconnect()
					table.clear(hittedHumans)
				end
			end)

			-- Automatyczne zniszczenie strzały po 5 sekundach jako zabezpieczenie
			game:GetService("Debris"):AddItem(arrow, 5)
		end
	end
end
-- Funkcja obsługująca aktywację narzędzia (strzelanie)
while wait(fireRate.Value * (1 + (upgrades[2].Increase * upgrades[2].PlayerHas) / 100)) do
	local player = game.Players:GetPlayerFromCharacter(tool.Parent) -- Pobranie gracza trzymającego narzędzie

	if player then
		local closestEnemy = findClosestEnemy(player)
		if closestEnemy then
			
			local doNoclip = false
			
			if upgrades[16].PlayerHas > 0 then
				
				local randomNumb = math.random(1,100)
				print(randomNumb, upgrades[16].PlayerHas * upgrades[16].Increase)
				
				if randomNumb <= upgrades[16].PlayerHas * upgrades[16].Increase then
					
					doNoclip = true
					
				end
				
			end
			
			local projectileNumber = projectiles.Value + upgrades[7].PlayerHas
			
			if projectileNumber == 1 then

				fireArrow1(closestEnemy, player, doNoclip)

			elseif projectileNumber == 2 then

				fireArrow2(closestEnemy, player, doNoclip)

			elseif projectileNumber == 3 then

				fireArrow3(closestEnemy, player, doNoclip)

			elseif projectileNumber == 4 then

				fireArrow4(closestEnemy, player, doNoclip)

			elseif projectileNumber == 5 then

				fireArrow5(closestEnemy, player, doNoclip)
			
			else
				
				warn("Invalid number of projectiles detected!")
			
			end

		end
	end
end
