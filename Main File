--[[ Originally made by Purble_Dev
Discord: @purbledev
Date: 10.05.2025
Enjoy!

QUICK HEADS UP:
This script is for taking care of enemies with your bow,
you can see how the script works in this game:
https://www.roblox.com/games/72409643525900/Idle-gamer
]]--

local handler = require(game.ServerScriptService.Handler)
local upgrades = handler.upgradesList

local tool = script.Parent
local fireRate = tool:WaitForChild("FireRate")
local range = tool:WaitForChild("Range")
local damage = tool:WaitForChild("Damage")
local projectileSpeed = tool:WaitForChild("ProjectileSpeed")
local projectiles = tool:WaitForChild("Projectiles")
local critChance = tool:WaitForChild("CriticalChance")
local critDmg = tool:WaitForChild("CriticalDamage")
local handle = tool:WaitForChild("Handle")
local fire = tool:WaitForChild("Fire")
local playerState = tool:WaitForChild("PlayerState")

local enemiesFolder = workspace:WaitForChild("Enemies")
local serverStorage = game:GetService("ServerStorage")
local TweenService = game:GetService("TweenService")
local arrowTemplate = serverStorage.Projectiles:WaitForChild("Arrow")

local originalPlayer

local lastShotTime = 0
local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)


-- function to create xp orbs
function makeOrbs(number, pos)
	for i = 1, number do
		local clone = game.ServerStorage.Orb:Clone()
		clone.Parent = workspace.Orbs
		clone.Position = pos
		clone.Size *= (1 + upgrades[15].Increase * upgrades[15].PlayerHas/100)

		clone:ApplyImpulse(Vector3.new(math.random(100, 300), 200, math.random(100, 300))) -- random impulse to make orbs move around
	end
end

local orbsTouched = {}

-- function to handle xp orbs collisions
workspace.Orbs.ChildAdded:Connect(function(orb)
	orb.Touched:Connect(function(hit)
		if orbsTouched[orb] or not game.Players:GetPlayerFromCharacter(hit.Parent) then
			return
		end
		orbsTouched[orb] = true
		orb.Collect.PlaybackSpeed = math.random(80, 120) / 100

		local player = game.Players:GetPlayerFromCharacter(hit.Parent)
		if player and player:FindFirstChild("Settings") and player.Settings:FindFirstChild("XP") then
			player.Settings.XP.Value += orb.XP.Value + orb.XP.Value*upgrades[11].PlayerHas * upgrades[11].Increase/100
		end

		orb:Destroy()
	end)
end)


-- function to create heal gems
function makeHealGems(number, pos)
	for i = 1, number do
		local clone = game.ServerStorage.Health:Clone()
		clone.Parent = workspace.HealGems
		clone.Position = pos

		clone:ApplyImpulse(Vector3.new(math.random(100, 300), 200, math.random(100, 300)))
	end
end

local healGemsTouched = {}

-- function to handle heal gems collisions
workspace.HealGems.ChildAdded:Connect(function(healGem)
	healGem.Touched:Connect(function(hit)
		if orbsTouched[healGem] or not game.Players:GetPlayerFromCharacter(hit.Parent) then
			return
		end
		orbsTouched[healGem] = true
		healGem.Collect.PlaybackSpeed = math.random(80, 120) / 100

		local player = game.Players:GetPlayerFromCharacter(hit.Parent)
		if player and player.Character then
			player.Character.Humanoid.Health += healGem.Health.Value + healGem.Health.Value*upgrades[13].PlayerHas * upgrades[13].Increase/100
		end

		healGem:Destroy()
	end)
end)

-- Function to handle enemy death, so you can get XP orbs and optional HP gems
local function setupEnemy(enemy)
	if enemy:FindFirstChild("Humanoid") and enemy:FindFirstChild("HumanoidRootPart") and enemy:FindFirstChild("XP") then
		enemy.Humanoid.Died:Connect(function()
			workspace.Settings.Info.Value = "Enemy "..enemy.Name.." died!"
			wait(1)
			workspace.Settings.Info.Value = ""

			local hmm = math.random(1,30)
			if hmm <= (1 + upgrades[14].Increase * upgrades[14].PlayerHas) then
				makeHealGems(2, enemy.HumanoidRootPart.Position)
			end

			if originalPlayer.Character then
				originalPlayer.Character.Humanoid.Health += (upgrades[12].Increase * upgrades[12].PlayerHas)/100 * originalPlayer.Character.Humanoid.MaxHealth
			end

			makeOrbs(enemy.XP.Value, enemy.HumanoidRootPart.Position)
			wait(.5)
			enemy:Destroy()
		end)
	end
end


-- Function to find the closest enemy within range
local function findClosestEnemy(player)
	local closestEnemy = nil
	local shortestDistance = range.Value + 1 + range.Value * (upgrades[6].Increase * upgrades[6].PlayerHas)/100 -- gets the shortest possible distance to find an enemy


	for _, enemy in pairs(enemiesFolder:GetChildren()) do -- goes through every enemy in the Enemies folder
		if enemy:FindFirstChild("HumanoidRootPart") then
			local humanoid = enemy:FindFirstChild("Humanoid")

			if humanoid and humanoid.Health > 0 then-- checks, if there's a humanoid and if its alive
				local enemyPosition = enemy.HumanoidRootPart.Position
				local distance = (enemyPosition - handle.Position).Magnitude

				if distance < shortestDistance then -- checks, if the distance to the enemy is smaller than distance to the closest enemy yet
					closestEnemy = enemy -- sets closest enemy to the (new) enemy with the shortest distance
					shortestDistance = distance -- sets the shortest distance to the distance of the (new) closest enemy
				end
			end
		end
	end

	return closestEnemy -- returns back with the closest enemy found
end


-- Function to calculate the direction and distance to the target
local function calculateTrajectory(arrowPosition, targetPosition)
	local direction = (targetPosition - arrowPosition).Unit -- calculate the direction
	local distance = (targetPosition - arrowPosition).Magnitude
	local travelTime = distance / projectileSpeed.Value / 5
	local trueDistance = distance / travelTime * 5 -- the actual distance
	local newTargetPosition = arrowPosition + (direction * trueDistance)
	return direction, newTargetPosition
end

-- Function to create and configure the arrow
local function createArrow(doNoclip)
	local arrow = arrowTemplate:Clone() -- clone the arrow and put it in workspace
	arrow.CFrame = handle.CFrame
	arrow.Parent = workspace

	if doNoclip == true then
		arrow.Highlight.OutlineColor = Color3.new(0.466667, 0.854902, 0.054902) -- turn to lime green color if arrow can noclip through
	end

	return arrow
end

-- Function to handle the arrow's movement
local function moveArrow(arrow, newTargetPosition)
	local tweenInfo = TweenInfo.new(5, Enum.EasingStyle.Linear) -- set the TweenInfo
	local tweenGoal = {Position = newTargetPosition}
	local arrowTween = TweenService:Create(arrow, tweenInfo, tweenGoal)
	arrowTween:Play() -- play the tween
end

-- Function to handle collision detection and damage application
local function handleCollision(arrow, targetEnemy, player, doNoclip)
	local hittedHumans = {}
	local traveledDistance = 0

	if targetEnemy and targetEnemy:FindFirstChild("HumanoidRootPart") then
		local connection
		connection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
			traveledDistance = traveledDistance + (projectileSpeed.Value * deltaTime)

			if not targetEnemy:FindFirstChild("HumanoidRootPart") then else local raycastResult = workspace:Raycast(arrow.Position, (targetEnemy.HumanoidRootPart.Position - arrow.Position).Unit * 2)
				if raycastResult then
					local hitPart = raycastResult.Instance
					local hitParent = hitPart.Parent
					local humanoid = hitParent:FindFirstChild("Humanoid")

					if hitParent == workspace.Map.Walls and not doNoclip then
						arrow:Destroy()
						connection:Disconnect()
					end

					if humanoid and humanoid.Health > 0 and hitParent ~= player.Character and not table.find(hittedHumans, humanoid) then
						table.insert(hittedHumans, humanoid)

						-- calculate the damage
						local rageBonus = 1
						if player.Character.Humanoid.Health / player.Character.Humanoid.MaxHealth <= 0.30 then
							rageBonus = 1 + (upgrades[17].Increase * upgrades[17].PlayerHas) / 100
						end

						local dmg = damage.Value * rageBonus
						if math.random(1, 100) <= critChance.Value then
							dmg = dmg * (critDmg.Value / 100)
						end

						if humanoid.Health - dmg <= 0 then
							setupEnemy(hitParent)
						end
						-- finally, deal the boosted (or not) damage to humanoid
						humanoid:TakeDamage(dmg)

						if not doNoclip then
							arrow:Destroy()
							connection:Disconnect()
						end
					end
				end
			end
		end)
	end
end

local function fireArrows(targetEnemy, player, doNoclip, arrowCount)
	if not targetEnemy or not targetEnemy:FindFirstChild("HumanoidRootPart") then
		return
	end

	fire.PlaybackSpeed = math.random(80, 110) / 100
	fire:Play()

	local targetPosition = targetEnemy.HumanoidRootPart.Position
	local baseDirection = (targetPosition - handle.Position).Unit
	local horizontalSpread = 0.08

	local startOffset = -(arrowCount - 1) / 2

	for i = 0, arrowCount - 1 do
		local offset = startOffset + i
		local spreadDirection = (baseDirection + Vector3.new(offset * horizontalSpread, 0, 0)).Unit

		local arrow = createArrow(doNoclip)

		local distance = (targetPosition - arrow.Position).Magnitude
		local travelTime = distance / projectileSpeed.Value / 5
		local trueDistance = distance / travelTime * 5

		local newTargetPosition = arrow.Position + (spreadDirection * trueDistance)

		arrow.CFrame = CFrame.new(arrow.Position, newTargetPosition)

		moveArrow(arrow, newTargetPosition)
		handleCollision(arrow, targetEnemy, player, doNoclip)
	end
end


-- Main loop
while wait(fireRate.Value * (1 + (upgrades[2].Increase * upgrades[2].PlayerHas) / 100)) do
	local player = game.Players:GetPlayerFromCharacter(tool.Parent) -- get player
	if not originalPlayer then originalPlayer = player end

	if player then
		local closestEnemy = findClosestEnemy(player) -- firing the function to find the closest enemy
		if closestEnemy then

			local doNoclip = false

			if upgrades[16].PlayerHas > 0 then

				local randomNumb = math.random(1,100)
				print(randomNumb, upgrades[16].PlayerHas * upgrades[16].Increase)

				if randomNumb <= upgrades[16].PlayerHas * upgrades[16].Increase then 

					doNoclip = true -- if player has the projectile collision upgrade, there's a chance for the arrow to pass through things, and even hit multiple enemies at once!
				end

			end

			local projectileNumber = projectiles.Value + upgrades[7].PlayerHas -- get number of projectiles that will be launched
			fireArrows(closestEnemy, player, doNoclip, projectileNumber)

		end
	end

end
